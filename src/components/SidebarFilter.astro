---
import type { Props } from "@astrojs/starlight/props";
import Default from "@astrojs/starlight/components/Sidebar.astro";
import { Kbd } from "starlight-kbd/components";
---

<div class="sidebar-filter-container">
  <div class="search-wrapper">
    <input
      type="text"
      id="sidebar-filter-input"
      placeholder="search..."
      aria-label="Filter sidebar"
    />
    <div class="kbd-hint">
      <Kbd mac="/" windows="/" />
    </div>
  </div>
  <div id="sidebar-filter-count" class="filter-count"></div>
</div>

<Default {...Astro.props}><slot /></Default>

<style>
  .sidebar-filter-container {
    padding: 1rem 1rem 0.5rem 1rem;
    position: sticky;
    top: 0;
    z-index: 10;
    background-color: var(--sl-color-bg-sidebar);
  }

  .search-wrapper {
    position: relative;
    display: flex;
    align-items: center;
  }

  #sidebar-filter-input {
    width: 100%;
    padding: 0.4rem 0.8rem;
    padding-right: 2.5rem;
    border-radius: 0.5rem;
    border: 1px solid var(--sl-color-gray-5);
    background: var(--sl-color-black);
    color: var(--sl-color-white);
    font-size: 0.85rem;
    outline: none;
    transition: border-color 0.2s;
  }

  #sidebar-filter-input:focus {
    border-color: var(--sl-color-accent-high);
  }

  .filter-count {
    font-size: 0.7rem;
    color: var(--sl-color-gray-3);
    margin-top: 0.25rem;
    height: 1rem;
    text-align: right;
  }

  /* pos */
  .kbd-hint {
    position: absolute;
    right: 0.5rem;
    top: 10%;
    pointer-events: none;
    opacity: 0.8;
  }

  /* hide hint when typing or focused */
  .search-wrapper:focus-within .kbd-hint {
    display: none;
  }

  /* hide items that don't match */
  :global(.sidebar-content [data-hidden="true"]) {
    display: none !important;
  }
</style>

<script>
  const input = document.getElementById(
    "sidebar-filter-input",
  ) as HTMLInputElement;
  const countDisplay = document.getElementById("sidebar-filter-count");

  //
  // cache sidebar structure and initial state
  const sidebarLinks = Array.from(
    document.querySelectorAll(".sidebar-content a"),
  ).map((link) => {
    const text = link.textContent?.toLowerCase() || "";
    return {
      el: link,
      listItem: link.closest("li"),
      //
      // normalized text: remove dots, spaces, and underscores for better matching
      normalized: text.replace(/[\s\._]/g, ""),
    };
  });

  const groups = Array.from(
    document.querySelectorAll(".sidebar-content details"),
  );
  const initialGroupStates = new Map(
    groups.map((g) => [g, (g as HTMLDetailsElement).open]),
  );

  input?.addEventListener("input", (e) => {
    const target = e.target as HTMLInputElement;
    const rawTerm = target.value.toLowerCase();
    const term = rawTerm.replace(/[\s\._]/g, "");
    let matchCount = 0;

    //
    // if search is empty, restore original expansion states
    if (term === "") {
      sidebarLinks.forEach((item) =>
        item.listItem?.setAttribute("data-hidden", "false"),
      );
      groups.forEach((group) => {
        (group as HTMLDetailsElement).open =
          initialGroupStates.get(group) || false;
        group.setAttribute("data-hidden", "false");
      });
      if (countDisplay) countDisplay.textContent = "";
      return;
    }

    //
    // filter items
    sidebarLinks.forEach((item) => {
      if (!item.listItem) return;

      const isMatch = item.normalized.includes(term);
      if (isMatch) {
        matchCount++;
        item.listItem.setAttribute("data-hidden", "false");

        //
        // if match, make sure all parent groups are expanded
        let parent = item.listItem.parentElement;
        while (parent && !parent.classList.contains("sidebar-content")) {
          if (parent.tagName === "DETAILS") {
            (parent as HTMLDetailsElement).open = true;
          }
          parent = parent.parentElement;
        }
      } else {
        item.listItem.setAttribute("data-hidden", "true");
      }
    });

    //
    // handle empty group headers by hiding groups if all children are hidden
    groups.forEach((group) => {
      const visibleChildren = group.querySelectorAll('li[data-hidden="false"]');
      if (visibleChildren.length === 0) {
        group.setAttribute("data-hidden", "true");
      } else {
        group.setAttribute("data-hidden", "false");
      }
    });

    //
    // update results counter
    if (countDisplay) {
      countDisplay.textContent =
        matchCount > 0 ? `${matchCount} matches found` : "no results";
    }
  });

  //
  // shortcut key: press '/' to focus
  window.addEventListener("keydown", (e) => {
    if (e.key === "/" && document.activeElement?.tagName !== "INPUT") {
      e.preventDefault();
      input?.focus();
      input?.select(); // select existing text for quick overwriting
    }
  });
</script>
